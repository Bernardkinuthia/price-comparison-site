#!/usr/bin/env python3
"""
EcommerceAPI Product Price Fetcher
Uses EcommerceAPI.io to fetch Amazon product prices and information
Updated to use third-party API instead of Amazon's Product Advertising API
"""

import pandas as pd
import json
import os
import logging
from datetime import datetime
import time
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed
from threading import Lock

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class EcommerceAPIClient:
    def __init__(self, api_key, domain='com', max_workers=10):
        self.api_key = api_key
        self.domain = domain
        self.base_url = 'https://api.ecommerceapi.io'
        self.max_workers = max_workers
        self.session = requests.Session()
        # Set headers for all requests
        self.session.headers.update({
            'User-Agent': 'ProductFetcher/1.0',
            'Accept': 'application/json'
        })
        
    def get_product(self, asin, retries=3):
        """Get product data from EcommerceAPI for a single ASIN"""
        url = f"{self.base_url}/amazon/product"
        
        params = {
            'api_key': self.api_key,
            'domain': self.domain,
            'asin': asin
        }
        
        for attempt in range(retries):
            try:
                response = self.session.get(url, params=params, timeout=30)
                response.raise_for_status()
                
                data = response.json()
                
                # Check if the API returned an error
                if 'error' in data:
                    logger.error(f"API error for ASIN {asin}: {data['error']}")
                def get_products_batch(self, asin_list, progress_callback=None):
        """Get multiple products using concurrent requests"""
        results = {}
        completed_count = 0
        lock = Lock()
        
        def fetch_single_product(asin):
            nonlocal completed_count
            result = self.get_product(asin)
            with lock:
                completed_count += 1
                if progress_callback:
                    progress_callback(completed_count, len(asin_list), asin)
            return asin, result
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # Submit all tasks
            future_to_asin = {
                executor.submit(fetch_single_product, asin): asin 
                for asin in asin_list
            }
            
            # Collect results as they complete
            for future in as_completed(future_to_asin):
                asin, result = future.result()
                results[asin] = result
        
        return results
                
                return data
                
            except requests.exceptions.RequestException as e:
                logger.warning(f"Attempt {attempt + 1} failed for ASIN {asin}: {e}")
                if attempt == retries - 1:
                    logger.error(f"All {retries} attempts failed for ASIN {asin}")
                    return None
                time.sleep(2 ** attempt)  # Exponential backoff
            except json.JSONDecodeError as e:
                logger.error(f"Invalid JSON response for ASIN {asin}: {e}")
                return None
        
        return None

class EcommerceProductFetcher:
    def __init__(self, csv_file='product_asin.csv', output_file='products.json', max_workers=10, rate_limit_delay=0.1):
        self.csv_file = csv_file
        self.output_file = output_file
        self.max_workers = max_workers
        self.rate_limit_delay = rate_limit_delay
        
        # Expected CSV columns for generator products
        self.expected_columns = [
            'asin',
            'Price',
            'Price/Watt', 
            'Running Watts',
            'Starting Watts',
            'Run Time',
            'Fuel Type',
            'Capacity',
            'Weight',
            'Affiliate Link'
        ]
        
        # Get API credentials from environment variables
        self.api_key = os.environ.get('ECOMMERCE_API_KEY')
        
        if not self.api_key:
            logger.error("Missing required environment variable: ECOMMERCE_API_KEY")
            raise ValueError("Missing EcommerceAPI credentials")
        
        self.api_client = EcommerceAPIClient(self.api_key, max_workers=self.max_workers)
    
    def clean_column_names(self, df):
        """Clean and standardize column names"""
        # Strip whitespace and standardize column names
        df.columns = df.columns.str.strip()
        
        # Map common variations to standard names
        column_mapping = {
            'runninh watts': 'Running Watts',  # Fix typo from your description
            'running watts': 'Running Watts',
            'starting watts': 'Starting Watts',
            'run time': 'Run Time',
            'fuel type': 'Fuel Type',
            'capacity': 'Capacity',
            'weight': 'Weight',
            'affiliate link': 'Affiliate Link',
            'price': 'Price',
            'price/watt': 'Price/Watt'
        }
        
        # Apply mapping
        df.columns = [column_mapping.get(col.lower(), col) for col in df.columns]
        
        return df
        
    def parse_api_response(self, response_data, asin):
        """Parse EcommerceAPI response and extract product information"""
        if not response_data:
            return None
        
        try:
            # Extract basic product information
            title = response_data.get('title', f"Product {asin}")
            
            # Get current Amazon price - EcommerceAPI provides exact_price
            amazon_price = None
            amazon_price_raw = None
            currency = '
    
    def merge_csv_data(self, product, csv_row):
        """Merge CSV data with API data for a single product"""
        if product is None:
            return None
            
        # Add all CSV columns to the product
        csv_data = {}
        
        for col in csv_row.index:
            if col.lower() != 'asin' and not pd.isna(csv_row[col]):
                value = str(csv_row[col]).strip()
                if value:  # Only add non-empty values
                    csv_data[col] = value
        
        # Add CSV data to product
        product.update(csv_data)
        
        # Calculate price per watt if we have both Amazon price and Running Watts
        if (product.get('amazon_price_raw') and 
            product.get('Running Watts')):
            try:
                running_watts = float(str(product['Running Watts']).replace(',', ''))
                if running_watts > 0:
                    price_per_watt = product['amazon_price_raw'] / running_watts
                    product['calculated_price_per_watt'] = round(price_per_watt, 4)
            except (ValueError, TypeError):
                pass
        
        return product
    
    def create_fallback_product(self, asin, csv_row=None):
        """Create a basic product entry when API fails"""
        product = {
            'asin': asin,
            'title': f"Product {asin}",
            'amazon_price': None,
            'amazon_price_raw': None,
            'currency': '$',
            'image_url': None,
            'features': [],
            'availability': 'Unknown',
            'rating': None,
            'review_count': None,
            'last_updated': datetime.utcnow().isoformat() + 'Z',
            'price_available': False,
            'api_source': 'EcommerceAPI',
            'error': 'API request failed'
        }
        
        if csv_row is not None:
            product = self.merge_csv_data(product, csv_row)
        
        return product
    
    def progress_callback(self, completed, total, current_asin):
        """Callback function to show progress"""
        percentage = (completed / total) * 100
        logger.info(f"Progress: {completed}/{total} ({percentage:.1f}%) - Last processed: {current_asin}")
        
        # Log every 10% or every 50 items, whichever comes first
        if completed % max(1, min(50, total // 10)) == 0 or completed == total:
            logger.info(f"✓ Processed {completed} products so far...")
    
    def run(self):
        """Main execution with concurrent processing"""
        logger.info("🚀 Starting EcommerceAPI product fetcher with concurrent processing...")
        
        # Read CSV
        try:
            df = pd.read_csv(self.csv_file)
            df = self.clean_column_names(df)
            logger.info(f"Found {len(df)} products in CSV")
            logger.info(f"CSV columns: {list(df.columns)}")
            logger.info(f"Using {self.max_workers} concurrent workers")
            
            # Check if ASIN column exists
            if 'asin' not in df.columns and 'ASIN' not in df.columns:
                logger.error("No 'asin' or 'ASIN' column found in CSV")
                return False
            
            # Standardize ASIN column name
            if 'ASIN' in df.columns and 'asin' not in df.columns:
                df['asin'] = df['ASIN']
                
        except Exception as e:
            logger.error(f"Error reading CSV: {e}")
            return False
        
        # Get ASINs from CSV and create mapping
        asin_to_row = {}
        asins = []
        
        for idx, row in df.iterrows():
            asin = str(row.get('asin', '')).strip()
            if asin and asin != 'nan' and not pd.isna(asin):
                asins.append(asin)
                asin_to_row[asin] = row
            else:
                logger.warning(f"No valid ASIN for row {idx + 1}, skipping")
        
        if not asins:
            logger.error("No valid ASINs found in CSV")
            return False
        
        logger.info(f"Processing {len(asins)} ASINs concurrently...")
        start_time = time.time()
        
        # Fetch all products concurrently
        results = self.api_client.get_products_batch(asins, self.progress_callback)
        
        # Process results
        all_products = []
        successful = 0
        
        for asin in asins:
            response_data = results.get(asin)
            csv_row = asin_to_row[asin]
            
            if response_data:
                # Parse the response
                product = self.parse_api_response(response_data, asin)
                
                if product:
                    # Merge with CSV data
                    product = self.merge_csv_data(product, csv_row)
                    
                    if product and product.get('price_available'):
                        successful += 1
                else:
                    # Create fallback product
                    product = self.create_fallback_product(asin, csv_row)
            else:
                # Create fallback product
                product = self.create_fallback_product(asin, csv_row)
            
            if product:
                all_products.append(product)
        
        end_time = time.time()
        total_time = end_time - start_time
        
        # Save to JSON
        try:
            output_data = {
                'last_updated': datetime.utcnow().isoformat() + 'Z',
                'total_products': len(all_products),
                'successful_prices': successful,
                'processing_time_seconds': round(total_time, 2),
                'average_time_per_product': round(total_time / len(all_products), 2),
                'concurrent_workers': self.max_workers,
                'api_used': 'EcommerceAPI',
                'csv_columns': list(df.columns),
                'products': all_products
            }
            
            with open(self.output_file, 'w') as f:
                json.dump(output_data, f, indent=2, default=str)
            
            logger.info(f"✅ Saved {len(all_products)} products to {self.output_file}")
            logger.info(f"📊 Success rate: {successful}/{len(all_products)} ({successful/len(all_products)*100:.1f}%)")
            logger.info(f"⏱️  Total processing time: {total_time:.1f} seconds")
            logger.info(f"🚀 Average time per product: {total_time/len(all_products):.2f} seconds")
            
            # Log sample product structure
            if all_products:
                logger.info("Sample product structure:")
                sample = {k: v for k, v in all_products[0].items() 
                         if k not in ['features']}
                for key, value in sample.items():
                    logger.info(f"  {key}: {value}")
            
            return True
            
        except Exception as e:
            logger.error(f"Error saving JSON: {e}")
            return False

if __name__ == "__main__":
    try:
        fetcher = EcommerceProductFetcher()
        success = fetcher.run()
        exit(0 if success else 1)
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        exit(1)
            
            # Use exact_price if available, fallback to parsing price string
            if 'exact_price' in response_data and response_data['exact_price']:
                amazon_price_raw = float(response_data['exact_price'])
                amazon_price = f"${amazon_price_raw:.2f}"
                currency = response_data.get('price_symbol', '
    
    def merge_csv_data(self, product, csv_row):
        """Merge CSV data with API data for a single product"""
        if product is None:
            return None
            
        # Add all CSV columns to the product
        csv_data = {}
        
        for col in csv_row.index:
            if col.lower() != 'asin' and not pd.isna(csv_row[col]):
                value = str(csv_row[col]).strip()
                if value:  # Only add non-empty values
                    csv_data[col] = value
        
        # Add CSV data to product
        product.update(csv_data)
        
        # Calculate price per watt if we have both Amazon price and Running Watts
        if (product.get('amazon_price_raw') and 
            product.get('Running Watts')):
            try:
                running_watts = float(str(product['Running Watts']).replace(',', ''))
                if running_watts > 0:
                    price_per_watt = product['amazon_price_raw'] / running_watts
                    product['calculated_price_per_watt'] = round(price_per_watt, 4)
            except (ValueError, TypeError):
                pass
        
        return product
    
    def create_fallback_product(self, asin, csv_row=None):
        """Create a basic product entry when API fails"""
        product = {
            'asin': asin,
            'title': f"Product {asin}",
            'amazon_price': None,
            'amazon_price_raw': None,
            'currency': '$',
            'image_url': None,
            'features': [],
            'availability': 'Unknown',
            'rating': None,
            'review_count': None,
            'last_updated': datetime.utcnow().isoformat() + 'Z',
            'price_available': False,
            'api_source': 'EcommerceAPI',
            'error': 'API request failed'
        }
        
        if csv_row is not None:
            product = self.merge_csv_data(product, csv_row)
        
        return product
    
    def run(self):
        """Main execution"""
        logger.info("🚀 Starting EcommerceAPI product fetcher...")
        
        # Read CSV
        try:
            df = pd.read_csv(self.csv_file)
            df = self.clean_column_names(df)
            logger.info(f"Found {len(df)} products in CSV")
            logger.info(f"CSV columns: {list(df.columns)}")
            
            # Check if ASIN column exists
            if 'asin' not in df.columns and 'ASIN' not in df.columns:
                logger.error("No 'asin' or 'ASIN' column found in CSV")
                return False
            
            # Standardize ASIN column name
            if 'ASIN' in df.columns and 'asin' not in df.columns:
                df['asin'] = df['ASIN']
                
        except Exception as e:
            logger.error(f"Error reading CSV: {e}")
            return False
        
        all_products = []
        successful = 0
        
        # Process each row
        for idx, row in df.iterrows():
            asin = str(row.get('asin', '')).strip()
            
            if not asin or asin == 'nan' or pd.isna(asin):
                logger.warning(f"No valid ASIN for row {idx + 1}, skipping")
                continue
            
            logger.info(f"Processing ASIN {idx + 1}/{len(df)}: {asin}")
            
            # Call EcommerceAPI
            response_data = self.api_client.get_product(asin)
            
            if response_data:
                # Parse the response
                product = self.parse_api_response(response_data, asin)
                
                if product:
                    # Merge with CSV data
                    product = self.merge_csv_data(product, row)
                    
                    if product and product.get('price_available'):
                        successful += 1
                        logger.info(f"✓ {asin}: {product.get('amazon_price', 'N/A')} - {product.get('title', '')[:50]}...")
                    else:
                        logger.info(f"○ {asin}: No price - {product.get('title', '') if product else 'Failed'}...")
                else:
                    # Create fallback product
                    product = self.create_fallback_product(asin, row)
                    logger.warning(f"✗ {asin}: Failed to parse API response")
            else:
                # Create fallback product
                product = self.create_fallback_product(asin, row)
                logger.warning(f"✗ {asin}: API request failed")
            
            if product:
                all_products.append(product)
            
            # Rate limiting - be respectful to the API
            time.sleep(0.5)  # 500ms delay between requests
        
        # Save to JSON
        try:
            output_data = {
                'last_updated': datetime.utcnow().isoformat() + 'Z',
                'total_products': len(all_products),
                'successful_prices': successful,
                'api_used': 'EcommerceAPI',
                'csv_columns': list(df.columns),
                'products': all_products
            }
            
            with open(self.output_file, 'w') as f:
                json.dump(output_data, f, indent=2, default=str)
            
            logger.info(f"✅ Saved {len(all_products)} products to {self.output_file}")
            logger.info(f"📊 Success rate: {successful}/{len(all_products)} ({successful/len(all_products)*100:.1f}%)")
            
            # Log sample product structure (without raw_api_data for brevity)
            if all_products:
                logger.info("Sample product structure:")
                sample = {k: v for k, v in all_products[0].items() 
                         if k not in ['features', 'raw_api_data']}
                for key, value in sample.items():
                    logger.info(f"  {key}: {value}")
            
            return True
            
        except Exception as e:
            logger.error(f"Error saving JSON: {e}")
            return False

if __name__ == "__main__":
    try:
        fetcher = EcommerceProductFetcher()
        success = fetcher.run()
        exit(0 if success else 1)
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        exit(1))
            elif 'price' in response_data:
                # Try to parse price from string
                import re
                price_text = str(response_data['price'])
                price_match = re.search(r'[\d,]+\.?\d*', price_text.replace(',', ''))
                if price_match:
                    amazon_price_raw = float(price_match.group())
                    amazon_price = f"${amazon_price_raw:.2f}"
            
            # Get main product image
            image_url = None
            if 'images' in response_data and response_data['images']:
                image_url = response_data['images'][0]
            
            # Get product features
            features = response_data.get('feature_bullets', [])
            
            # Get additional useful information
            availability = response_data.get('availability_status', 'Unknown')
            rating = response_data.get('average_rating')
            review_count = response_data.get('total_reviews', '').replace(' ratings', '').replace(' rating', '')
            
            # Try to extract numeric review count
            if review_count:
                import re
                review_match = re.search(r'[\d,]+', str(review_count).replace(',', ''))
                if review_match:
                    review_count = int(review_match.group())
                else:
                    review_count = None
            
            product = {
                'asin': asin,
                'title': title,
                'amazon_price': amazon_price,
                'amazon_price_raw': amazon_price_raw,
                'currency': currency,
                'image_url': image_url,
                'features': features,
                'availability': availability,
                'rating': rating,
                'review_count': review_count,
                'brand': response_data.get('brand', ''),
                'is_prime_eligible': response_data.get('is_prime_exclusive', False),
                'last_updated': datetime.utcnow().isoformat() + 'Z',
                'price_available': amazon_price is not None,
                'api_source': 'EcommerceAPI'
            }
            
            return product
            
        except Exception as e:
            logger.error(f"Error parsing API response for ASIN {asin}: {e}")
            return None
    
    def merge_csv_data(self, product, csv_row):
        """Merge CSV data with API data for a single product"""
        if product is None:
            return None
            
        # Add all CSV columns to the product
        csv_data = {}
        
        for col in csv_row.index:
            if col.lower() != 'asin' and not pd.isna(csv_row[col]):
                value = str(csv_row[col]).strip()
                if value:  # Only add non-empty values
                    csv_data[col] = value
        
        # Add CSV data to product
        product.update(csv_data)
        
        # Calculate price per watt if we have both Amazon price and Running Watts
        if (product.get('amazon_price_raw') and 
            product.get('Running Watts')):
            try:
                running_watts = float(str(product['Running Watts']).replace(',', ''))
                if running_watts > 0:
                    price_per_watt = product['amazon_price_raw'] / running_watts
                    product['calculated_price_per_watt'] = round(price_per_watt, 4)
            except (ValueError, TypeError):
                pass
        
        return product
    
    def create_fallback_product(self, asin, csv_row=None):
        """Create a basic product entry when API fails"""
        product = {
            'asin': asin,
            'title': f"Product {asin}",
            'amazon_price': None,
            'amazon_price_raw': None,
            'currency': '$',
            'image_url': None,
            'features': [],
            'availability': 'Unknown',
            'rating': None,
            'review_count': None,
            'last_updated': datetime.utcnow().isoformat() + 'Z',
            'price_available': False,
            'api_source': 'EcommerceAPI',
            'error': 'API request failed'
        }
        
        if csv_row is not None:
            product = self.merge_csv_data(product, csv_row)
        
        return product
    
    def run(self):
        """Main execution"""
        logger.info("🚀 Starting EcommerceAPI product fetcher...")
        
        # Read CSV
        try:
            df = pd.read_csv(self.csv_file)
            df = self.clean_column_names(df)
            logger.info(f"Found {len(df)} products in CSV")
            logger.info(f"CSV columns: {list(df.columns)}")
            
            # Check if ASIN column exists
            if 'asin' not in df.columns and 'ASIN' not in df.columns:
                logger.error("No 'asin' or 'ASIN' column found in CSV")
                return False
            
            # Standardize ASIN column name
            if 'ASIN' in df.columns and 'asin' not in df.columns:
                df['asin'] = df['ASIN']
                
        except Exception as e:
            logger.error(f"Error reading CSV: {e}")
            return False
        
        all_products = []
        successful = 0
        
        # Process each row
        for idx, row in df.iterrows():
            asin = str(row.get('asin', '')).strip()
            
            if not asin or asin == 'nan' or pd.isna(asin):
                logger.warning(f"No valid ASIN for row {idx + 1}, skipping")
                continue
            
            logger.info(f"Processing ASIN {idx + 1}/{len(df)}: {asin}")
            
            # Call EcommerceAPI
            response_data = self.api_client.get_product(asin)
            
            if response_data:
                # Parse the response
                product = self.parse_api_response(response_data, asin)
                
                if product:
                    # Merge with CSV data
                    product = self.merge_csv_data(product, row)
                    
                    if product and product.get('price_available'):
                        successful += 1
                        logger.info(f"✓ {asin}: {product.get('amazon_price', 'N/A')} - {product.get('title', '')[:50]}...")
                    else:
                        logger.info(f"○ {asin}: No price - {product.get('title', '') if product else 'Failed'}...")
                else:
                    # Create fallback product
                    product = self.create_fallback_product(asin, row)
                    logger.warning(f"✗ {asin}: Failed to parse API response")
            else:
                # Create fallback product
                product = self.create_fallback_product(asin, row)
                logger.warning(f"✗ {asin}: API request failed")
            
            if product:
                all_products.append(product)
            
            # Rate limiting - be respectful to the API
            time.sleep(0.5)  # 500ms delay between requests
        
        # Save to JSON
        try:
            output_data = {
                'last_updated': datetime.utcnow().isoformat() + 'Z',
                'total_products': len(all_products),
                'successful_prices': successful,
                'api_used': 'EcommerceAPI',
                'csv_columns': list(df.columns),
                'products': all_products
            }
            
            with open(self.output_file, 'w') as f:
                json.dump(output_data, f, indent=2, default=str)
            
            logger.info(f"✅ Saved {len(all_products)} products to {self.output_file}")
            logger.info(f"📊 Success rate: {successful}/{len(all_products)} ({successful/len(all_products)*100:.1f}%)")
            
            # Log sample product structure (without raw_api_data for brevity)
            if all_products:
                logger.info("Sample product structure:")
                sample = {k: v for k, v in all_products[0].items() 
                         if k not in ['features', 'raw_api_data']}
                for key, value in sample.items():
                    logger.info(f"  {key}: {value}")
            
            return True
            
        except Exception as e:
            logger.error(f"Error saving JSON: {e}")
            return False

if __name__ == "__main__":
    try:
        fetcher = EcommerceProductFetcher()
        success = fetcher.run()
        exit(0 if success else 1)
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        exit(1)
